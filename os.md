# 硬件结构

## 冯诺依曼模型

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.png)

计算机基本结构为以下五个部分

- 运算器
- 控制器
- 存储器
- 输入设备
- 输出设备

## 内存

- 程序和数据都是存储在内存中的，存储的基本单位为 byte，1 字节等于8 bit，每一个字节对应一个内存地址。
- 内存地址从0开始编号，自增排列最后一个地址为内存总字节数 - 1
- 内存读写任何一个数据的速度都是一样的

## 中央处理器

- 即CPU，由冯诺依曼模型中的控制器和运算器组成，还有多种类寄存器
  - 控制器：负责控制CPU的工作
  - 运算器：负责运算
  - 寄存器：主要作用是存储计算时的数据，相比于内存，速度更快
    - 通用寄存器：存放需要进行运算的数据
    - 程序计数器：存储CPU要执行的下一条指令内存地址
    - 指令寄存器：存放当前正在执行的指令本身
- 32位CPU和64位CPU的主要区别在于一次能计算多少字节数据。32位一次计算4byte，64位一次计算8byte，位数越大，一次能计算的数值就越大

## 总线

用于CPU和内存以及其他设备之间的通信，可分为三种

- 地址总线，用于指定CPU将要操作的内存地址
- 数据总线，用于读写内存的数据
- 控制总线，用于发送和接收信号，比如中断。CPU响应也需要控制总线

CPU读写内存数据流程

1. 通过**地址总线**指定内存地址
2. 通过**控制总线**控制是读或写命令
3. 通过**数据总线**传输数据

## 输入输出设备

输入设备负责向计算机输入数据，输出设备负责将计算机计算后的结果输出

# 操作系统结构

## 内核

![内核](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8/Kernel_Layout.png)

计算机有各种外部硬件设备组成，如内存、CPU、硬盘。如果每个应用直接与设备通信太麻烦了。于是操作系统让内核作为应用连接硬件设备的桥梁，应用只需要关心与内核交互，而不用关心硬件的细节

### 内核的能力

- 进程调度。内核管理进程、线程，决定哪个进程线程使用CPU
- 内存管理。内核决定内存的分配与回收
- 提供硬件通信能力。
- 提供系统调用。作为用户程序与操作系统之间的接口

### 内核工作方式

内核具有很高的权限，可以控制硬件。而应用程序权限很小，因此大多数OS将内存分为两个区域

- 内核空间，只有内核程序可以访问
- 用户空间，专门给应用程序使用，应用和内核都可以访问
- 当程序使用用户空间时，被称为在用户态执行。使用内核空间时，成为在内核态执行
- 应用程序想访问内核空间，需要进行系统调用产生中断，由内核程序完成

## Linux的设计

- 多任务，指操作系统可以同时执行多个任务
  - 对于单核CPU，并发执行
  - 多核CPU，多个任务可被不同核心同时执行，并行执行
- 对称多处理，指每个CPU地位相等，多个CPU共享内存
- ELF可执行文件链格式
- 宏内核，指Linux的内核是一个完整的可执行程序，且拥有最高权限
  - 特征是应用内核所有模块都运行在内核态。如进程调度、内存管理、文件管理等

## 中断和异常

CPU运行两种程序，内核程序和中断程序

合适情况下，OS kernel会把内核CPU使用权交给应用程序

中断是**让OS夺回CPU使用权**的唯一途径

用户态 -> 内核态

- 通过内核执行一条**特权指令触发**
- 指令会修改PSW标志位，意味着OS主动让出CPU使用权

内核态 -> 用户态

- 由**中断引发**，硬件自动完成状态切换
- 会修改PSW标志位，意味着OS夺回CPU使用权

中断的两种类型

![image-20240710193413512](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240710193413512.png)



- 内中断（也称异常）
  - 与当前执行的指令有关
  - 中断信号来源于CPU内部
  - 若CPU**想要OS内核提供的服务**，会执行一条特殊的指令--**陷入指令**，引发内中断
  - 若当前执行的指令是非法的，会引发一个内中断信号
    - 除零
    - 用户态越权执行特权指令
- 外中断（狭义的中断）
  - 与当前执行的指令无关
  - CPU每个指令周期结束要检查一下是否有外中断需要处理
  - 中断信号来源于CPU外部
    - 时钟中断，时间片用完切换程序
    - IO中断，通知IO事件

## 系统调用

是OS给应用程序提供的，应用程序可通过系统调用来请求OS内核的服务

# 进程管理

## 进程的组成

进程是进程实体的运行过程，是系统进行资源分配的一个独立单位

- PCB，进程控制块，是给操作系统使用的
- 程序段，程序的代码（指令序列）
- 数据段，运行过程中产生的各种数据（如变量等）

### PCB

进程控制块，是进程存在的唯一标识。当进程创建时，操作系统为其创建PCB，当进程结束时，会回收PCB

- 进程描述信息
  - 进程标识符 PID
  - 用户标识符 UID
- 进程控制和管理信息
  - CPU、硬盘、网络流量使用情况统计
  - 进程当前状态，阻塞就绪运行
- 资源分配清单
  - 正在使用哪些文件
  - 正在使用那些内存区域
  - 正在使用那些IO设备
- 处理机相关信息
  - PSW状态位
  - PC等各种寄存器的值，用于实现进程切换

### 进程间通信

进程是资源分配的基本单位，进程间不可互相访问内存空间

- 共享存储
  - 基于存储区的共享
    - 通过系统调用申请一片内存区
    - 再次通过系统调用将共享内存区映射进进程虚拟内存页表项
    - 灵活性高速度快
    - 各进程对共享区的访问应是互斥的
  - 基于数据结构的共享
    - 比如存一个长度为10的数组
    - 共享方式速度慢，限制多
    - 是一种低级通信方式
- 消息传递
  - 以格式化的消息为单位
    - 包括消息头和消息体
    - 消息头包括 发送进程ID、接收进程ID、消息长度等格式化信息
  - 通过OS提供的发送消息 / 接收消息 两个原语进行数据交换
  - 消息传递方式
    - 直接通信方式：消息要指明接收进程的PID
    - 间接通信方式：通过信箱
- 管道通信
  - 相当于一个特殊的共享文件，其实就是在内存中开辟出的一个固定大小的内存缓冲区
  - 半双工，同一时间只有一个流向
  - 各进程要互斥的访问管道（由OS实现
  - 数据读写是先进先出的
  - 管道写满时，写进程将阻塞，直到读进程将管道中的数据取走
  - 管道读空时，读进程将阻塞，直到写进程往管道中写入数据

## 线程

线程是一个基本的CPU执行单元，也是程序执行流的最小单位

进程内的线程可通过占用不同CPU实现并行

引入线程后，进程只作为除CPU之外的系统资源的分配单位（IO设备、内存地址空间都是分配给进程的）

线程拥有线程ID（TID）、和线程控制块（TCB）

### 实现方式

早期的OS只支持进程不支持线程，当时的线程是由线程库实现的，成为用户级线程

后来OS实现了内核级线程，作为CPU运行的单位，实现了进程内多线程并行

- 用户级线程
  - 线程的管理工作由应用程序实现的
  - 线程切换不需要进行系统调用（用户态转变为内核态
  - 操作系统意识不到用户级线程的存在
  - 优点：不涉及到CPU切换内核态，开销小，效率高
  - 缺点：某个”线程“被阻塞则整个进程被阻塞，并发度不高，多线程不能并行
- 内核级线程
  - 线程的管理工作由OS实现
  - 线程切换需要进行系统调用（用户态转变为内核态
  - OS能看到的线程，会给每个线程分配TCB
  - 优点：当一个线程被阻塞，别的线程还可运行。并发度高，可占用不同核心并行
  - 缺点：切换涉及CPU切换内核态，有开销

### 多线程模型

为了避免用户级线程和内核级线程的缺点，提出在已实现内核级线程的系统上，继续实现用户级线程。并通过绑定用户级线程到内核级线程，避免了用户级线程模型和内核级线程模型各自的缺点，称之为多线程模型

- 一对一模型
  - 一个用户级线程映射到一个内核级线程
  - 退化成内核级线程模型
- 多对一模型
  - 多个用户级线程映射到一个内核级线程
  - 退化成用户级线程模型
- 多对多模型
  - 一个用户级进程的n个用户级线程模型映射到m个内核级线程（n >= m)
  - 克服了多对一模型并发度不高的缺点：多对多模型下用户级线程可并行运行，且不会互相阻塞
  - 克服了一对一模型开销台的的缺点：进程（而不是OS）对用户级线程进行调度

## 处理机调度

### 三个层次

- 高级调度（作业调度
  - 按某种规则，从后备队列中选择合适的作业并将其调入到内存，并为其创建进程
  - 外存到内存
  - 发生频率低
  - 无 到 创建态 到 就绪态
- 中级调度（内存调度
  - 按某种规则，从挂起队列中选择合适的进程，将其市局从外存调回内存
  - 外存到内存
  - 发生频率中等
  - 挂起态 到 就绪态
- 低级调度（进程调度
  - 按某种规则，从就绪的队列选择一个进程并为其分配处理级
  - 内存到CPU
  - 发生频率最高
  - 就绪态 到 运行态

### 进程调度

#### 调度时机

- 当运行的进程主动放弃处理机
  - 进程正常终止
  - 运行发生异常而终止
  - 请求阻塞（等待IO
- 被动放弃处理机
  - OS分配给进程的时间片用完
  - 有更紧急的事情要处理（如IO中断
  - 有更高优先级的进程进入就绪队列
- 不能调度的情况
  - 处理中断时
  - 进程在OS内核临界区
  - 原子操作过程中

#### 切换过程

指一个进程让出处理机，并选择另一个进程占用处理机。由调度器实现

流程如下，其实就是切换上下文，有较大开销

1. 对原来运行进程各种数据的保存
2. 对新进程各种数据的恢复

#### 调度方式

- 非抢占式
  - 只允许进程主动放弃处理机
  - 实现简单，系统开销小但是无法处理紧急任务，适合早期批处理系统
- 抢占式
  - 进程占用的处理机会被剥夺
  - 可以让进程按时间片轮流执行（通过时钟中断
  - 适用于分时操作系统、实时操作系统

#### 调度算法

## 进程同步与互斥

- 进程同步
  - 并发带来异步性，但有时需要通过进程互相配合完成工作，需要有先后顺序
- 进程互斥
  - 对临界资源的访问，需要互斥的进行，即一个时间段内只允许一个进程访问该资源
  - 空闲让进
  - 忙则等待
  - 优先等待（不要被饥饿
  - 让权等待（当进程不能进入临界区，应当立即释放处理机，防止忙等

### 互斥算法

#### 软件实现方法

#### 硬件实现方法

#### 信号量机制

用一个整形的变量作为信号量，来表示系统中某种资源的数量

- P操作，等待进入临界区
- V操作，退出临界区

## 死锁

对不可剥夺的资源的不合理分配可能导致死锁

死锁：各进程（资源申请者）互相等待对方手里的资源，导致各进程都阻塞，无法向前推进

饥饿：由于长时间得不到想要的资源，某进程无法向前推进

死循环：某个程序执行过程中跳不出某个循环，有时是bug，又是故意执行

### 必要条件

- 互斥条件，只有**对必须互斥使用的资源的争抢**才会导致死锁
- 不剥夺条件，进程获得的资源未使用完之前，**不能被夺走**，只能主动释放
- 请求和保持：进程保持已有的资源**不放手的同时申请**其他已被占有的资源
- 循环等待：存在循环等待

# 内存管理

## 虚拟内存

- 将进程使用到的地址隔离开来，OS为每个进程分配一套独立的虚拟地址，依次实现进程间内存隔离，进而支持多任务
- 进程不能访问物理地址，只能访问虚拟地址
- 虚拟地址到物理地址的操作由OS完成，对于进程是透明的
- 进程持有的虚拟地址通过CPU芯片中的内存管理单元（MMU）来进行映射

### 内存分段

### 内存分页

### 段页式内存管理

### Linux内存布局

# 文件系统

# 设备管理

