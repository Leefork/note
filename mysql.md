# SELECT执行流程

![查询语句执行流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png)

## MySQL架构

### Server层

- 连接器
  - 和客户端建立连接，接收请求
  - TCP三次握手
  - 验证用户名和密码
  - 获取用户权限，对后续请求进行权限判断
    - 建立连接后，管理员修改用户权限，不影响已建立的连接
  - 查看连接数 show processlist
  - 最大空闲连接
    - 设置 wait_timeout ，超时自动断开
    - 执行 kill connection 手动断开
    - 断开后客户端要发起新请求才能得知
  - 连接数限制
    - max_connections 控制，超过这个之后新请求会被拒绝
    - 长连接：三次握手后执行多个SQL，再断开
      - 长连接占用内存增多，可定期断开长连接，或客户端主动重置连接
      - 现在后端一般用连接池
    - 短链接：三次握手后执行一个SQL，就断开
- 查询缓存
  - MySQL8.0已被删除
  - 执行select会判断是否有缓存，有则直接返回
- 解析器
  - 解析SQL
    - 词法分析
    - 语法分析生成语法树
- 预处理器
  - 检查查询的表或字段是否存在
  - 将 * 替换为表上所有列
- 优化器
  - 确定SQL执行方案，生成执行计划
    - 决定使用哪个索引
    - 判断是否索引覆盖
  - 可以执行 explain 查看执行计划
- 执行器
  - 调用存储引擎层API接口获取数据

### 存储引擎层

- 负责数据的存储和提取
- 支持多个不同存储引擎
  - InnoDB
  - MyISAM
  - Memory
- 管理索引文件和数据文件
- 查询方式
  - 主键索引查询
    - 查询条件用到了主键
    - 如果是等值查询，则访问类型为const
  - 全表扫描
    - 查询条件没用到索引
  - 索引下推
    - 用于减少二级索引在查询时的回表操作
    - 满足一下条件
      - 二级索引
      - 联合索引
      - 左侧字段使用到了索引，右侧字段没使用到，但也处于查询条件中
    - 会将右侧字段是否匹配的逻辑换为在存储引擎层执行，减少回表操作

# 锁

## 锁的划分

锁按**粒度**可分为

- 全局锁
- 表锁
- 行锁 InnoDB引擎独有

按**模式**可分为

- 共享读锁 S锁
- 共享写锁 X锁

## 全局锁

```sql
#添加全局锁
flush tables with read lock;
#释放全局锁
unlock tables;
```

添加全局锁后整个表处于只读状态，其他线程的的DML和DQL将被阻塞。

用于MyISAM做全库逻辑备份，InnoDB由于是RR隔离级别，不需要这种方式备份。

## 表级锁

### 表锁

```
#S锁
lock tables t_student read;

#X锁
lock tables t_student write;

#释放
unlock tables;
```

尽量避免使用，影响性能

元数据锁 MDL

不需要显示调用，目的是为了防止对数据库CRUD时表结构被修改。

对表进行CRUD时自动添加MDL读锁

对表结构变更时自动添加MDL写锁

有MDL读锁时，添加读锁写锁都会被阻塞，即对表结构进行变更时，阻塞其他CRUD和表结构变更命令

### 意向锁

InnoDB引擎专有，目的是为了快速判断表里记录是否添加了锁。

添加表锁时，要判断表中是否有记录行锁，如果有则会阻塞。

为了防止判断时需要遍历整个表，于是给表加上意向锁，阻塞添加表锁的操作，意向锁只会和表锁互斥。

对表中记录上S行锁前，对表加上意向S锁

对表中记录上X行锁前，对表加上意向X锁

### AUTO-INC锁

为了实现自增。插入数据时添加一个自增锁，添加完后释放。

## 行锁

InnoDB引擎支持

锁是加在索引上而不是行上



update默认使用Next-Key Lock，但会在一些条件下退化成Record Lock 或 Gap Lock

如果update where使用了唯一索引，则Next-Key Lock 退化成Record Lock

如果update where没有使用索引，就会全表扫描，对所有记录加Next-Key Lock，相当于锁住全表

### Next-Key Lock

Record Lock + Gap Lock 的组合，锁住一个范围，并且锁住记录本身，前开后闭

用来避免幻读现象

- Record Lock 记录锁，仅仅锁住一条记录
- Gap Lock 间隙锁，锁住一个范围，但不包含记录本身。前开后开

#### 唯一索引等值查询

- 查询的记录存在，Next-Key Lock退化成记录锁
- 查询的记录，退化成间隙锁

#### 唯一索引范围查询

#### 非唯一索引等值查询

## 死锁

必要条件

- 互斥
- 占有且等待
- 不可强占用
- 循环等待

解决方案：

- 设置事务等待锁的超时时间
- 开启主动死锁检测

# 索引

## 索引的分类

### 数据结构分类

- B+Tree
  - 多叉树，节点存储多个值，节点内值按序。一以此减少高度，减少IO
  - 非叶节点只存放索引，不存放数据，减少树高
  - 叶节点双向链表以支持范围查询
- Hash
- Full-test

### 物理存储分类

- 主键索引
  - 聚簇索引，叶节点存储数据
  - 非聚簇索引，叶节点存储数据地址
- 二级索引（辅助索引）
  - 叶节点存储主键值
  - 进行查询时获取主键值
    - 如果select索引覆盖，则直接返回
    - 否则回表从主键B+Tree查到数据

### 字段特性分类

- 主键索引
  - 一个表只能有一个
  - 主键值非空
  - 建表时根据不同场景选择主键索引
    - 有主键，直接用
    - 没主键，选择第一个不包含Null值的为一列作为索引
    - 都没有，使用隐式自增id作为索引
  - 物理实现为聚簇索引或非聚簇索引
- 唯一索引
  - 值不能重复，可以为多条记录为空
- 普通索引
- 前缀索引
  - 对字符类型的前几个字符建立索引，减少索引占用存储，提高查询效率

### 字段个数分类

- 单列索引
  - 只对一个字段进行索引
- 联合索引
  - 对多个字段进行索引
  - 区分度大的尽量排前面
  - 最左匹配原则，由于查询优化器存在，顺序不重要

## 索引的实现

- InnoDB引擎
  - B+Tree 实现
  - 主键索引为聚簇索引，叶节点记录行数据本身
  - 其他索引为二级索引，叶节点记录主键值
  - 如果查询时使用了二级索引，则先通过二级索引查主键值，再通过主键值查数据（此操作称为回表），需要查两颗B+Tree。
  - 索引覆盖：查询的字段在索引中。如where的条件是添加了二级索引的字段，select的字段是主键或where的字段
- MyISAM引擎
  - B+Tree的聚簇索引，叶节点记录数据物理地址

## 索引要求

数据库需要将数据持久化到磁盘，数据包括索引数据和行数据

- 尽可能少的磁盘IO
- 高效的查找
- 高效的插入
- 支持范围查找

## 考虑以下数据结构

- 二叉查找树
  - 特点：所有左节点小于中间节点，右节点大于中间节点。可以O(log(N))查找和插入
  - 缺点：左右不平衡，自增主键插入退化成链表、树高度可能很高，导致多次磁盘IO
- AVL平衡二叉查找树
  - 在二叉查找树基础上解决了左右不平衡，可能会退化成链表的问题
- B树
  - 不再限制一个节点只能由2个子节点，而是允许多个子节点，降低树高。每个节点可容纳子节点树成为B树的阶
- B+树
  - 在B树上做升级，有以下几点：
    - 叶子节点存放实际数据，非叶子节点存放索引，因此比B树更矮
    - 叶子节点构成双向有序链表，支持范围查询
    - 书上有大量冗余节点，防止频繁复杂变化

## 索引缺点

- 占用更多存储
- 创建和维护需要耗时，随着数据量增大而增大
- 降低DML效率，因为要维护B+树

## 索引优化

- 前缀索引优化
  - 字符串类型字段索引使用前缀索引
  - order by无法使用前缀索引
  - 不能使用索引覆盖
- 索引覆盖
  - select的字段加入索引，避免回表
- 主键索引最好自增
  - 聚簇索引插入只用追加，不需要修改之前的数据页
  - 避免了页分裂（从中间插入会造成）
- 主键最好用integer，维护B+Tree效率高
- 防止索引失效
  - 做匹配
  - 对索引字段进行运算
  - or
  - 联合索引非最左匹配

## 执行计划

- possible_key字段可能用到的索引
- key实际用到的索引
- key_len索引长度
- rows扫描到的数据行数
- type数据扫描类型

### 数据扫描类型

- All 全表扫描
- index 索引扫描
- range 索引范围扫描
  - 一般是使用了 >、 <、 in、 between，只用检索给定范围的行
- ref 非唯一索引扫描
  - 非唯一索引等值查询
  - 唯一索引的前缀查询
- eq_ref 唯一索引扫描
  - 使用主键或唯一索引的等值查询，用于多表连接查询
- const 结果只有一条的主键或唯一索引扫描
  - 主键等值查询，用于等值常量查询

### Extra

- Using filesort 
  - 查询语句包含group by且无法利用索引完成排序，需要使用排序算法实时排序，效率很低要避免
- Using temporary 
  - 使用了临时表保存中间结果，一般在对结果排序时使用，常见于group by和order by，效率低要避免
- Using index
  - 用到了索引覆盖，不用回表，效率高

## 索引失效

### 索引失效

#### 字符串使用左模糊匹配

由于字符串字段索引是按字符串前缀排序的，使用左模糊没办法用到排好序的索引B+Tree

#### 对索引使用函数

索引B+Tree使用索引原始值排序的

8.0版本后增加了函数索引，对函数计算后的值建立一个索引

#### 对索引进行表达式计算

同上

#### 对索引进行隐式类型转换

同上

#### 联合索引非最左匹配

最左字段必须出现在查询中，顺序不重要，因为有查询优化器

索引截断，会导致索引下推，在遍历索引过程中排除不符合条件的数据

特殊情况：索引覆盖情况下会执行索引扫描，而不是全表扫描

#### where子句中使用or

需要全表扫描将or中满足条件的筛选

解决方案：对没有添加索引的添加单列索引，查询优化器会对结果集进行合并

# 存储结构

## 文件

/var/lib/mysql/database_name/

- db.opt 存储默认字符集和字符校验规则 
- .frm 存储表结构信息
- .ibd 存储表数据

## 表数据存储结构

- 段
  - 区内存储的数据是不同的，通过段管理存储不同数据类型的区
  - 索引段
    - 存放B+树非叶子节点的区集合
  - 数据段
    - 存放B+树的叶子结点的区集合
  - 回滚段
    - 存放的是回滚数据（undolog）的区集合
- 区
  - 分配空间的单位，为了使相邻页的物理位置也相邻，防止顺序读写时产生大量随机IO
  - 默认1MB
- 页
  - 页是IO操作的单位，默认16KB
  - 页包含多个行
  - 多种类型
    - 数据页：存放行数据
    - undo日志页
    - 溢出页：大对象一个页存不了，则用链表方式存在溢出页中
- 行
  - 记录是按行存放的，行存放于页中

## InnoDB行格式

### COMPACT行格式

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png)

- 记录的额外信息
  - 变长字段长度列表
    - 记录变长字段长度列表
    - 按列的顺序逆序存放，为了提高CPU Cache命中率
    - NULL不存放
    - 没有变长字段时不存储该列表
  - NULL值列表
    - 每个允许NULL值列对应一个二进制位，逆序存放
    - 用整数个字节的位来表示，位数不够补零
    - 数据表的字段都定义成NOT NULL时，没有NULL值列表
  - 记录头信息
    - delete_mask
      - 标识数据是否被删除
      - 执行delete时不会真正删除记录，只是将delete_mask标记为1
    - next_record
      - 写一条记录的位置
    - record_type
      - 当前记录的类型
      - 0 普通记录 1 非叶子节点记录 2 最小记录 3 最大记录
- 记录的真实信息
  - 隐藏字段
    - row_id
      - 如果没有唯一主键且没有唯一约束列，则添加row _id隐藏字段，标识唯一一条数据
      - 占用6字节
    - trx_id
      - 事务id，标识由哪个事务生成
      - 必须有的字段，6个字节
    - roll_pointer
      - 记录上一个版本的指针
      - 必须有的字段，7个字节

# Buffer Pool

## why need？

每次操作都从磁盘读数据，性能很差，因此增加buffer pool作为缓存。如果数据被装入了缓存，则下次使用直接从缓存读取。

- 当读取数据时，如果数据存在于Buffer Pool中，则使用时直接读取Buffer Pool中的数据，否则再去磁盘中读取
- 当修改数据时，先修改Buffer Pool中的数据页，然后将数据页设置为脏页，有后台进程将脏页写入到磁盘

## Buffer Pool有多大

MySQL启动时向操作系统申请的一片连续的内存空间，默认配置 128MB，一般建议配置成可用物理内存的60%~80%

## 缓存什么

缓存数据页、索引页、undo页、插入缓存、自适应哈希索引、锁信息等

## 如何管理

创建每个页的控制块，并放置于Buffer Pool头部

- 缓存页的表空间
- 页号
- 缓存页地址
- 链表节点

Pool维护了一下几张数据结构

- Free链表
  - 记录空闲页信息。记录头节点、尾节点、节点数量
  - 节点是空闲页控制块的地址，每个节点对应一个空闲页
  - 从磁盘加载页时，从空闲页取节点
- Flush链表
  - 记录被修改过数据的页，更新数据时将对应缓存页标记为脏页
  - 后台线程定期将脏页刷盘
- LRU链表
  - 管理脏页+干净页，经常查询的数据缓存在其中
  - 页访问时移动到头节点
  - 页添加时添加到头节点，淘汰尾节点
- LRU优化
  - 预读失效：由于空间局部性，MySQL加载数据页时会将相邻数据页一起加载进来，以此减少磁盘IO。但提前被加载进来的页，可能并不会被访问，造成预读失效。
  - 分为young和old两个区域，预读页插入old区，被访问时才进入young区。
  - Buffer Pool污染：SQL扫描大量数据，可能会将Buffer Pool大量页被替换为只会访问一次的数据，导致大量热数据被淘汰。
  - 对停留在old的时间做判断，在时间间隔内才会从old移动到young，提高了进入young的门槛

# 缓存一致性

数据库和缓存的整体操作不是原子性的，再加上并发读写，可能会造成数据库和缓存数据不一致的问题

读的逻辑都是先查询缓存，缓存不存在则查询数据库并写回缓存

读的逻辑有以下方案

## 先更新数据库，后更新缓存

![图片](https://img-blog.csdnimg.cn/img_convert/8febac10b14bed16cb96d1d944cd08da.png)

并发导致缓存和数据库数据不一致

## 先更新缓存，后更新数据库

![图片](https://img-blog.csdnimg.cn/img_convert/454a8228a6549176ad7e0484fba3c92b.png)

并发导致缓存和数据库数据不一致

## 先删缓存，再更新数据库

![图片](https://img-blog.csdnimg.cn/img_convert/cc208c2931b4e889d1a58cb655537767.png)

读写并发时，缓存和数据库不一致

## 先更新数据，后更新缓存

![图片](https://img-blog.csdnimg.cn/img_convert/1cc7401143e79383ead96582ac11b615.png)

缓存和数据库不一致

## 延迟双删

先删缓存，再写数据库。sleep后再删缓存

# InnoDB存储数据

由于每次读取要进行一次I/O操作，每次处理一行效率很低，所以InnoDB以页为单位存储数据，读取也是以页为单位。

InnoDB数据页默认大小为 16KB

## 数据页结构

![img](https://img-blog.csdnimg.cn/img_convert/8ea6f9361ad8adac588c3b48737e140c.png)

InnoDB 的数据是按「数据页」为单位来读写的，默认数据页大小为 16 KB。每个数据页之间通过双向链表的形式组织起来，物理上不连续，但是逻辑上连续。

数据页内包含用户记录，每个记录之间用单项链表的方式组织起来，为了加快在数据页内高效查询记录，设计了一个页目录，页目录存储各个槽（分组），且主键值是有序的，于是可以通过二分查找法的方式进行检索从而提高效率。

为了高效查询记录所在的数据页，InnoDB 采用 b+ 树作为索引，每个节点都是一个数据页。

如果叶子节点存储的是实际数据的就是聚簇索引，一个表只能有一个聚簇索引；如果叶子节点存储的不是实际数据，而是主键值则就是二级索引，一个表中可以有多个二级索引。

在使用二级索引进行查找数据时，如果查询的数据能在二级索引找到，那么就是「索引覆盖」操作，如果查询的数据不在二级索引里，就需要先在二级索引找到主键值，需要去聚簇索引中获得数据行，这个过程就叫作「回表」



# QA

## count(*) 和count(1)性能

count(*) = count(1) > count(key) > count(field)

### count作用

聚合函数，统计符合查询条件记录中，函数指定的参数不为null的记录数

### count执行过程

#### count(1)

循环向表读取一条记录，每次循环count+1

- 只有主键索引，则遍历主键索引的聚簇索引
- 有二级索引，则遍历二级索引，因为数据量更小，IO成本小

#### count(*)

同count(1)

#### count(key)

主键nullable，则性能小于count(1)，因为读取数据后要判断是否为null

主键not null，则跟count(1)一致

#### count(field)

- 没有索引，全表扫描
- 有索引，扫描索引

### count优化

- 使用explain获取近似值
- 额外保存计数值
- select max



## 表引擎

- MyISAM引擎
  - MyISAM不支持事务，索引为非聚簇索引
- InnoDB引擎
  - InnoDB支持事务，索引为聚簇索引
  - InnoDB支持行级锁，使用Next-Key Lock避免提供解决幻读的方案
  - InnoDB支持MVCC，提供解决不可重复度的方案

## varchar(n)中n最大取值

一行数据存储的最大字节数是6553565535

max(n) = (65535 - null值列表长度 - 变长字段列表长度)/ 字符集单个字符最大字节数

## update没带索引

会扫描全表，对所有记录加锁

# 高可用

## 主从复制

1. 主库的数据通过 binlog 复制到从库

2. 从库存在IO Thread拉取主库binlog，并写入relaylog

3. 从库存在SQL Thread执行relaylog命令


- 分两个线程为了防止大量写请求造成IO阻塞SQL执行
- 从库不是越多越好，太多会占用太多主库带宽

主从复制主要有三种模式

- 同步复制 主库提交事务要等从库复制成功后才返回客户端
- 异步复制 提交事务写入binlog就返回，主库宕机会造成数据丢失
- 半同步复制 只要有任一从库同步成功就返回客户端

## 读写分离

通过 agent 分流请求，主库接收写请求，通过 binlog 复制到从库，从库接受读请求

## 一致性

两阶段提交

- 先记录redolog，置为prepare
- 记录binlog
- redolog置为commit

主库宕机后，从库升为主库

从库执行binlog，主库执行commit 的 redolog保证数据一致性



# 事物

## 事务特性

- A 原子性
  - 一次操作要么全部执行要么全部不执行
  - 事务执行过程中发生错误，则回滚到事务开始前的状态
  - 使用undolog实现
- C 一致性
  - 最基本属性
  - 有其它四个特性来保证
- I 隔离性
  - 事务操作互相隔离不影响
  - MVCC 加 锁 实现
- D 持久性
  - 事务提交后持久化到硬盘
  - redolog 实现

## 隔离性

多个客户端连接并发处理事务会引发问题，隔离性就是要解决并发带来的脏读、不可重复读、幻读的问题

### 脏读

指一个事物读取到了另一个**未提交事务**修改过的数据

事务未提交则随时可能发生回滚，这样的话事务B读到的数据就跟预想的不一致

### 不可重复读

一个事物内多次读取同一数据，如果前后两次读取到的数据不一致，意味着发生不可重复读。通常是读取到了另一个事物提交的update数据

### 幻读

一个事物内多次查询某个符合条件的记录数量，如果出现前后两次查询到的记录数量不一样的情况，意味着发生了幻读。通常指读取到了另一个事物insert的数据

## 事务隔离级别

- 读未提交，指一个事务还没提交时，它做的变更就能被其他事务看到，直接读取最新的数据
  - 脏读
  - 不可重复读
  - 幻读
- 读提交，指一个事务提交之后，它做的变更才能被其他事务看到
  - 不可重复读
  - 幻读
  - 解决了脏读，方案：MVCC，每个语句执行前生成读快照
- 可重复读，一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的
  - 解决了不可重复读，方案：MVCC在事务启动时生成快照
  - 解决部分幻读
    - 快照读，通过MVCC
    - 当前读，通过记录锁+间隙锁
    - 不能解决的场景
      - 执行快照读后执行update
      - 执行快照读后，其他事务执行insert，事务1再执行当前读
      - 解决方案：开启事务后立即执行select for update 上Next-Key Lock
- 串行化
  - 读写锁避免并行访问

## MVVC

快照的思想

数据维护**版本链**

事务维护一个**快照结构体**

查询数据时，快照结构体与版本链进行可见性算法运算，可以获得**快照创建时**数据的内容

#### ReadView结构

![img](https://img-blog.csdnimg.cn/img_convert/11a65cbc2e97f6855d7692a265dc2651.png)

- m_ids
  - 创建ReadView时，当前数据库中活跃事务的id列表
  - 活跃事务指已启动但未提交的事务
- min_trx_id
  - 创建ReadView时，m_ids中id最小的事务id
- max_trx_id
  - 创建ReadView时，数据库将要分配的下一个事务id值
- creator_trx_id
  - 当前ReadView的事务id

#### 聚簇索引隐藏列

- trx_id
  - 当一个事务对某条记录进行改动，就会把该事务的事务id记录在trx_id隐藏列里
- roll_pointer
  - 每次对记录进行改动，会把旧版本的记录写入到undo日志中，隐藏列是一个指针，指向旧版本记录，同过旧版本记录找到历史值。旧版本记录会记录全部字段内容，包括隐藏字段。
  - roll_pointer形成版本链

### 可见性算法

- 当前记录的 **trx_id < ReadView.min_trx_id** 说明记录的修改是之前已提交事务生成的，所以该版本的记录对当前事务**可见**
- 当前记录的 **trx_id >= ReadView.max_trx_id** 说明记录的修改是创建ReadView后启动事务生成的，所以该版本的记录对当前事务**不可见**
- 当前记录的 **ReadView.min_trx_id <= trx_id < ReadView.max_trx_id** 
  - 如果 **trx_id in ReadView.m_ids** 说明生成该版本的活跃事务在ReadView生成时依然活跃，则该版本记录对当前事务**不可见**
  - 如果 **trx_id not in ReadView.m_ids** 说明生成该版本记录的活跃事务已提交，该版本记录对当前事务**可见**

#### 读提交

事物开始时创建ReadView

#### 读未提交

每次执行读取都生成一个新的ReadView，这种情况下，ReadView结构体内容会变化，导致读取到新提交的值

## 解决幻读

InnoDB默认引擎是可重复度，但这个可重复读通过行锁 Next-Key Lock 来锁住记录之间的间隙和记录本身，防止其他事务在这个纪录之间插入新的记录，来避免幻读

# 日志

## 普通业务日志

### slowlog

慢查询日志，可配置，记录慢查询SQL

### errorlog

记录失败SQL日志

## 备份、复制相关

### binlog

归档日志，记录DML和DQL

用于数据备份和主从复制

### relaylog

从主库binlog复制来的，换了个名字

## 持久化日志

### redolog

- InnoDB引擎使用了WAL预写日志功能。MySQL的写操作是先记录日志再执行操作。事物提交时，先将redolog持久化到磁盘，再等Buffer Pool的脏页持久化到磁盘。redolog是追加写，性能更好
- 由于Buffer Pool的存在，会有断电导致数据丢失的问题。因为脏页没有持久化，但可通过redolog恢复数据至最新状态
- 物理日志，只记录对某个数据页做了什么修改
- 也存在redolog buffer

## 事务日志

### undolog

- 事务处理过程中，如果出现了错误或用户执行了rollback，可利用undolog将历史数据恢复到事务开始之前的状态。实现事务回滚，保证**原子性**
- 每条记录保存多分历史数据，通过链表连接，即版本链，用于**MVCC**
- undolog何时刷盘：和数据页刷盘策略一样

## binlog和redolog区别

- 适用对象不同
  - binlog为server层实现的日志，所有存储引擎都可以使用
  - redolog为InnoDB引擎实现的日志，主要是解决Buffer Pool持久化问题
- 文件格式不同
  - binlog：3种格式类型
    - statement：记录命令
    - row：记录修改后的数据
    - mixed：混用，写时智能选择
  - redolog：物理日志，记录页数据的修改
- 写入方式不同
  - binlog 追加写，写满新建，不覆盖旧日志，保存全量日志
  - redolog循环写，日志大小固定，写满就从头写。藏页刷盘后清理旧日志
- 用途不同
  - binlog用于备份恢复、主从同步
  - redolog用于掉电等故障恢复

